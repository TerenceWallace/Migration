<?xml version="1.0"?>
<doc>
<assembly>
<name>
Migration
</name>
</assembly>
<members>
<member name="T:My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="P:My.Resources.Resources.NamespaceBuildings">
<summary>
  Looks up a localized string similar to Migration.Buildings.
</summary>
</member>
<member name="F:Migration.Common.StackType.Query">
 <summary>
 A query is provided with resources.
 </summary>
</member>
<member name="F:Migration.Common.StackType.Provider">
 <summary>
 A provider serves resource queries.
 </summary>
</member>
<member name="T:Migration.Common.MovableType">
 <summary>
 Currently there are only Migrants.
 </summary>
</member>
<member name="M:Migration.Configuration.Loader.GetWalkResult(Migration.Point)">
 <summary>
 Answers the question is movable allowed to move to a certain point
 </summary>
 <param name="entry"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Migration.Game.Map.SimulationLoop">
 <summary>
 This is where updates take place and the game is saved
 </summary>
 <remarks></remarks>
</member>
<member name="M:Migration.Game.MapFile.ReadNext(Migration.Game.Map)">
 <summary>
 Read the next stored command, executes it for the given game map and returns
 the cycle time for the next command. This method should be used in a while loop
 until the return value is higher to the current cycle time...
 </summary>
 <param name="inTarget"></param>
</member>
<member name="T:Migration.Rendering.Renderer">
 <summary>
 This class and the whole GLRenderer-Assembly is expected to change heavily in near future, 
 this is why I skip many documentation at this point.
 </summary>
</member>
<member name="M:Migration.Rendering.Renderer.InitializeGLContext(System.Int32,System.Int32)">
 <summary>
 One time initialization of a new GL context. Must be called from within the render thread!
 </summary>
 <param name="inPixelWidth">Pixel width of the viewport.</param>
 <param name="inPixelHeight">Pixel height of the viewport.</param>
</member>
<member name="M:Migration.Rendering.Renderer.UpdateViewport(System.Int32,System.Int32)">
 <summary>
 Should be called whenever the surface changes its size and properly
 updates the GL viewport and other related properties.
 </summary>
 <param name="inPixelWidth">Pixel width of the viewport.</param>
 <param name="inPixelHeight">Pixel height of the viewport.</param>
</member>
<member name="M:Migration.Rendering.Renderer.InitializeStopWatch">
 <summary>
 
 </summary>
 <remarks></remarks>
</member>
<member name="M:Migration.Rendering.Renderer.CreateControl(System.Windows.Forms.ContainerControl)">
 <summary>
 This is only intended for AnimationEditor and provides limited functionality!
 </summary>
 <returns></returns>
</member>
<member name="M:Migration.Rendering.Renderer.Dispose">
 <summary>
 In case of this method is called automatically on exit.
 In case of you have to call it yourself when the renderer
 is no longer needed.
 </summary>
</member>
<member name="M:Migration.Rendering.Renderer.AttachTerrain(Migration.TerrainDefinition)">
 <summary>
 Even if the parameter type might seem misleading, its just because we need to register
 some events, so its not enough to just have the terrain array.
 </summary>
 <param name="inTerrain"></param>
</member>
<member name="M:Migration.Rendering.TerrainRenderer.CreateMovableOrientedAnimation(Migration.Character,Migration.Movable,System.Double)">
 <summary>
 "Internal" method used by AnimationEditor.
 </summary>
</member>
<member name="M:Migration.Rendering.TerrainRenderer.CreateAnimation(Migration.Character,Migration.Interfaces.IPositionTracker,System.Double)">
 <summary>
 "Internal" method used by AnimationEditor.
 </summary>
</member>
<member name="T:Migration.Rendering.RenderException">
 <summary>
 Just a wrapper for exceptions thrown by GLRenderer.Check
 </summary>
</member>
<member name="T:Migration.Rendering.SpriteEngine">
 <summary>
 Seems a little odd to me that some hundred texture switches and GL.Begin/End clauses in conjunction
 with alpha blending are killing even a GTX 260, so here is the solution, a fast sprite engine based
 on alpha test instead of blending and using texture atlas as well as radix sort to schedule rendering
 tasks according to these atlas. Further, it supports three different modes of texture atlas 
 generation. The first one just generates them on the fly, which is rather expensive but fills the
 cache file with data for mode two, which will be used on next start then. Mode two uses usual bitmap
 images stored in the texture cache as atli, but still has to convert them into the driver internal format
 on the fly. The third mode needs manual processing by letting Migration generate texture atli for
 all animation library frames. These frames are stored as PNG files and can now be converted into DXT3
 compressed DDS files (NVidia Photoshop plugin or whatever) manually. Then another invokation of Migration
 will extend the image data in the texture cache with its DDS data. Next time the game loads, it will now
 directly use the compressed images within the texture cache, without any postprocessing done by the driver.
 Mode three is meant for production use, whereas the first two modes are the default setting for development,
 since they work fully automatic. We still have to keep the original image data in mode three, since some
 systems might not support DXT3 and thus need the uncompressed image data...
 </summary>
</member>
<member name="M:Migration.Rendering.SpriteEngine.RadixRenderSchedule(System.Int32,Migration.Common.Procedure{Migration.RectangleDouble})">
 <summary>
 This is a little specialized, but since we are only dealing with frames in the main render pipeline,
 it is suiteable to have such a shortcut. The following will schedule the given task according to the
 atlas containing the given frame. When <see cref="M:Migration.Rendering.SpriteEngine.EndRadixRender"/> is finally called, each atlas is
 only bound once to OpenGL and all tasks scheduled for this particular atlas are invoked. Further, we
 know that we are dealing with sprites here and thus only one GL.Begin/End clause is used per atlas,
 together resulting in the maximum performance one can archieve with sprites. The scheduling is performed
 in practical constant time, radix sort...
 </summary>
 <param name="inFrameIndex"></param>
 <param name="inTask">A callback, receiving the texture atlas subimage area in UV coordinates.</param>
</member>
<member name="T:Migration.Rendering.NativeTexture">
 <summary>
 A native texture currently does nothing more than providing a convenient way
 to load bitmap images into the rendering pipeline. 
 </summary>
</member>
<member name="F:Migration.Rendering.NativeTexture.privateNode">
 <summary>
 If a renderer is used, it will store a texture reference here for
 fast list operations.
 </summary>
</member>
<member name="P:Migration.Rendering.NativeTexture.ID">
 <summary>
 The internal OpenGL texture ID.
 </summary>
</member>
<member name="M:Migration.Rendering.NativeTexture.Finalize">
 <summary>
 Checks whether all unmanaged resources were released properly.
 </summary>
</member>
<member name="M:Migration.Rendering.NativeTexture.Dispose">
 <summary>
 Properly releases all unmanaged resources.
 </summary>
</member>
<member name="M:Migration.Rendering.NativeTexture.#ctor(System.Drawing.Bitmap)">
 <summary>
 If a renderer is given, the texture is registered for automatic 
 release. If you pass null, it's your duty to call <see cref="M:Migration.Rendering.NativeTexture.Dispose"/> before GC.
 </summary>
</member>
<member name="M:Migration.Rendering.NativeTexture.SetPixels(System.Drawing.Bitmap,System.Byte[])">
 <summary>
 If image is already compressed, the following method will load it directly, omitting any unneccessary internal
 postprocessing in the OpenGL implementation/driver. But since compression is system dependent, you must also
 provide the original image in case the given compression is not supported. If this is the case, the method
 will behave exactly as SetPixel.
 </summary>
</member>
<member name="M:Migration.Rendering.NativeTexture.Bind">
 <summary>
 Binds the texture to the rendering pipeline.
 </summary>
</member>
<member name="T:Migration.Rendering.Program">
 <summary>
 Provides convenient access to GLSL programs. As with other OpenGL related 
 unmanaged resources, you MUST dispose any allocated instance explicitly,
 otherwise you will get an exception by the time such an leaking object is GCed.
 </summary>
 <remarks>
 Currently shaders are required for object selection, but also to stay conform
 to the OpenGL ES 2.0 Specification, which withdraws all fixed-functions as well
 as many other convenient APIs. Later, the terrain rendering engine will make
 heavy use of shaders.
 </remarks>
</member>
<member name="F:Migration.Rendering.Program.privateWorldMatrixLocation">
 <summary>
 Uniform ID of world matrix.
 </summary>
</member>
<member name="F:Migration.Rendering.Program.privateWorldITMatrixLocation">
 <summary>
 Uniform ID of the inverse transform of the world matrix.
 </summary>
</member>
<member name="F:Migration.Rendering.Program.privateModelMatrixLocation">
 <summary>
 Uniform ID of model matrix.
 </summary>
</member>
<member name="F:Migration.Rendering.Program.privateViewMatrixLocation">
 <summary>
 Uniform ID of view matrix.
 </summary>
</member>
<member name="F:Migration.Rendering.Program.privateTextureLocation">
 <summary>
 If used by shader, the uniform ID of stage textures.
 </summary>
</member>
<member name="P:Migration.Rendering.Program.ProgramID">
 <summary>
 The GLSL program ID. Needed to set custom shader parameters for example.
 </summary>
</member>
<member name="F:Migration.Rendering.Program.privateVertexShader">
 <summary>
 The vertex shader belonging to this program. Also see <see cref="P:Migration.Rendering.Program.AutoDisposeShaders"/>.
 </summary>
</member>
<member name="F:Migration.Rendering.Program.privatePixelShader">
 <summary>
 The pixel shader belonging to this program. Also see <see cref="P:Migration.Rendering.Program.AutoDisposeShaders"/>.
 </summary>
</member>
<member name="F:Migration.Rendering.Program.privateAutoDisposeShaders">
 <summary>
 If true, then both shaders will automatically be disposed if this GLSL program
 is disposed.
 </summary>
</member>
<member name="M:Migration.Rendering.Program.Finalize">
 <summary>
 A resource leak check. Due to wrong thread context, we usually can't release OpenGL resources
 in class destructors!
 </summary>
</member>
<member name="M:Migration.Rendering.Program.Dispose">
 <summary>
 Releases all unmanaged resources associated with this program.
 If <see cref="P:Migration.Rendering.Program.AutoDisposeShaders"/> is NOT set, then you will have to
 dispose both shaders yourself.
 </summary>
</member>
<member name="M:Migration.Rendering.Program.#ctor(Migration.Rendering.Shader,Migration.Rendering.Shader,System.Boolean)">
 <summary>
 Creates a new GLSL program from shaders.
 </summary>
 <param name="inVertexShader">A valid vertex shader.</param>
 <param name="inPixelShader">A valid pixel shader.</param>
 <param name="inAutoDisposeShaders">True, if both shaders should be disposed when this program is being disposed.</param>
</member>
<member name="M:Migration.Rendering.Program.Bind(OpenTK.Matrix4,OpenTK.Matrix4,OpenTK.Matrix4)">
 <summary>
 Binds this program to the pipeline, setting all three matricies.
 </summary>
</member>
<member name="M:Migration.Rendering.Program.Unbind">
 <summary>
 Unbinds the program from the pipeline.
 </summary>
</member>
<member name="T:Migration.Rendering.RenderableCharacter">
 <summary>
 Renders a whole Character.
 </summary>
</member>
<member name="T:Migration.Rendering.RenderableVisual">
 <summary>
 This class provides the finest level of control about visual rendering.
 It will render the given native texture according to all other given
 parameters.
 </summary>
 <remarks>
 At the beginning it might be confusing what exactly a width or height value,
 for example, means. The thing is that it depends on configuration.  
 Just thread virtual pixels as real pixel size, only scaled by internal parameters.
 
 With OpenGL always keep in mind that the we have to call ALL GL commands
 withtin the same thread, usually the internal render loop thread. So any
 methods and properties exposed to the public MUSTN'T call any GL commands,
 instead the calls shall be deferred.
 </remarks>
</member>
<member name="F:Migration.Rendering.RenderableVisual.privateAspectRatio">
 <summary>
 The ratio between width and height initially passed to the constructor.
 </summary>
</member>
<member name="F:Migration.Rendering.RenderableVisual.privateTexture">
 <summary>
 Internally allows to set a custom texture at any time, may also be null.
 </summary>
</member>
<member name="F:Migration.Rendering.RenderableVisual.privateRenderer">
 <summary>
 The parent renderer.
 </summary>
</member>
<member name="F:Migration.Rendering.RenderableVisual.privateScale">
 <summary>
 Default is one, and denotes the scaling factor for the whole rendered object.
 </summary>
</member>
<member name="F:Migration.Rendering.RenderableVisual.privateIsVisible">
 <summary>
 Should be rendered at all?
 </summary>
</member>
<member name="F:Migration.Rendering.RenderableVisual.privateBuildingProgress">
 <summary>
 Usuall set to 1.0, which also provides the fastest rendering using only one quad.
 For building animations, this will use a special subdivided, incomplete quad to
 so that by incrementally adding parts, the building gets more and more visible.
 </summary>
</member>
<member name="F:Migration.Rendering.RenderableVisual.privateZShiftOverride">
 <summary>
 By default, the Z-Shift is set to the terrain height at the position trackable's 
 coordinates. In case of resource stacks or animated movables this isn't sufficient.
 So if this field has a value, it will be used as Z-Shift instead.
 </summary>
</member>
<member name="M:Migration.Rendering.RenderableVisual.#ctor(Migration.Rendering.TerrainRenderer,Migration.CyclePoint)">
 <summary>
 
 </summary>
 <param name="inParent">The parent renderer.</param>
</member>
<member name="M:Migration.Rendering.RenderableVisual.Render(Migration.Common.RenderPass)">
 <summary>
 Renders the object with default parameters.
 </summary>
</member>
<member name="M:Migration.Rendering.RenderableVisual.Render(Migration.Common.RenderPass,System.Int32,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Is intended for derived classes and provides a way to fine tune the final
 size of the rendered object according to additional frame size and offsets.
 </summary>
 <param name="inOffsetX">Virtual pixel offset in X direction.</param>
 <param name="inOffsetY">Virtual pixel offset in Y direction.</param>
 <param name="inWidth">Virtual pixel width; overrides the instance width for this call.</param>
 <param name="inHeight">Virtual pixel height; overrides the instance height for this call.</param>
</member>
<member name="T:Migration.Rendering.Shader">
 <summary>
 Provides convenient access to GLSL shaders. As with other OpenGL related 
 unmanaged resources, you MUST dispose any allocated instance explicitly,
 otherwise you will get an exception by the time such an leaking object is GCed.
 Also see <see cref="T:Migration.Rendering.Program"/>.
 </summary>
</member>
<member name="F:Migration.Rendering.Shader.privateType">
 <summary>
 Vertex- or pixelshader?
 </summary>
</member>
<member name="F:Migration.Rendering.Shader.privateSource">
 <summary>
 Source code for the shader.
 </summary>
</member>
<member name="P:Migration.Rendering.Shader.ShaderID">
 <summary>
 OpenGL specific shader ID.
 </summary>
</member>
<member name="M:Migration.Rendering.Shader.Finalize">
 <summary>
 A resource leak check. Due to wrong thread context, we usually can't release OpenGL resources
 in class destructors!
 </summary>
</member>
<member name="M:Migration.Rendering.Shader.Dispose">
 <summary>
 Releases all unmanaged resources associated with this shader.
 </summary>
</member>
<member name="M:Migration.Rendering.Shader.#ctor(System.String)">
 <summary>
 Loads a new shader from file. For performance reasons, shaders might be
 cached later on, but this won't have an impact on this API.
 </summary>
 <param name="inFileName">A file containing the shader source code.</param>
</member>
<member name="M:Migration.Rendering.TerrainMesh.ComputeOcclusion">
 <summary>
 Does a fast and accurate occlusion query for visible terrain cells.
 </summary>
 <returns></returns>
</member>
<member name="M:Migration.Rendering.TerrainMesh.RenderBlocks(Migration.Rectangle,System.Boolean)">
 <summary>
 Renders all blocks necessary to overlay the given rectangle of terrain cells.
 </summary>
 <param name="inContainedCells"></param>
</member>
<member name="M:Migration.Rendering.TerrainMesh.InvalidateCell(System.Int32,System.Int32)">
 <summary>
 Marks a given terrain cells as invalid, resulting in the underlying vertex
 block being updated on next rendering. This is a very fast operation!
 </summary>
</member>
<member name="M:Migration.Rendering.TerrainMesh.ValidateBlock(System.Int32,System.Int32)">
 <summary>
 Ensures that the given block is up to date and if not, fetches all required data from
 the renderer and propagates changes to GPU memory.
 </summary>
</member>
<member name="M:Migration.AnimationUtilities.SynchronizeTaskImpl(Migration.Common.Procedure)">
 <summary>
 Schedules the given task for execution at the next rendering cycle. 
 </summary>
</member>
<member name="T:Migration.Character">
 <summary>
 A Character represents the topmost animation object. For example it may contains
 all animations available for a given object class like a "sawmill". There is an ambient
 animation, always visible as animation background. This might be the sawmill itself.
 Then there are animation sets. Each set represents another "animation type". Such a type
 may consist of several animations, blended together, constructing the final animation
 for a given type. There can only be one active type per Character. Of course you could
 just ignore animation types and put the whole thing as single animation with little variations
 into the class again and again, but this will just blow up the file size. The Character
 provides a way to split animations into little pieces, saving a lot of file space.
 </summary>
</member>
<member name="P:Migration.Character.AmbientSet">
 <summary>
 The ambient set is always visible in the background (can be null). The animation will be auto-repeated.
 </summary>
</member>
<member name="M:Migration.AnimationLibrary.RegisterAndPreventGC">
 <summary>
 Registers the library in a static list <see cref="P:Migration.AnimationLibrary.Libraries"/>. This will prevent
 the library from being GCed. You are responsible to call <see cref="M:Migration.AnimationLibrary.UnregisterAndAllowGC"/> when
 you don't need this library anymore. You only need to register a library, when it should expose
 shared animations.
 </summary>
</member>
<member name="T:Migration.AnimationSet">
 <summary>
 An animation set is able to play several animations simultaneously.
 </summary>
</member>
<member name="E:Migration.Buildings.Workshop.OnProducedCustomItem">
 <summary>
 Is called whenever a production cycle for a <see cref="F:Migration.Common.Resource.Max"/> provider
 is completed. Please be very careful, since this event is raised (for sake of synchronization)
 within the main simulation loop and should be completed within microsecond orders of magnitudes!
 </summary>
</member>
<member name="M:Migration.Buildings.Workshop.SelectProvider">
 <summary>
 This method may be overwritten to weight production probabilities according to
 user configuration (weapon and tool smith).
 </summary>
</member>
<member name="M:Migration.Buildings.Workshop.Update">
 <summary>
 Is not to be called every cycle, since it is an expensive function.
 </summary>
</member>
<member name="M:Migration.Buildings.Factory.Update">
 <summary>
 Is not to be called every cycle, since it is an expensive function.
 </summary>
</member>
<member name="T:Migration.Core.BaseGenericCollection`1">
 <summary>
 A basic generic class that can be used for any type of collection
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Migration.Core.BaseGenericCollection`1.Delete(`0)">
 <summary>
 Deletes an item from the collection.
 If items that are being deleted from this collection, need to update a persistant store, use this list to update your persistant store.
 </summary>
 <param name="t"></param>
</member>
<member name="M:Migration.CooperativeAStar.Search(Migration.Movable,Migration.PathNodeKey,Migration.PathNodeKey,Migration.Common.WallValue)">
 <summary>
 Returns null, if no path is found. Start- and End-Node are included in returned path. The user context
 is passed to IsWalkable().
 </summary>
</member>
<member name="M:Migration.RoutingNodeAStar.Initialize(Migration.RoutingNode)">
 <summary>
 Returns null, if no path is found. Start- and End-Node are included in returned path. The user context
 is passed to IsWalkable().
 </summary>
</member>
<member name="T:Migration.Rectangle">
 <summary>
 To prevent System.Drawing dependency just for this structure.
 </summary>
</member>
<member name="T:Migration.CyclePoint">
 <summary>
 A cycle point is a key element in deterministic, discretized space-time. Even if it provides
 double values for rendering, it internally uses exact integers to manage its "solid" state.
 </summary>
</member>
<member name="P:Migration.CyclePoint.XCycles">
 <summary>
 The only deterministic way to change a cycle point, by raw cycle manipulation.
 </summary>
</member>
<member name="P:Migration.CyclePoint.YCycles">
 <summary>
 The only deterministic way to change a cycle point, by raw cycle manipulation.
 </summary>
</member>
<member name="P:Migration.CyclePoint.XGrid">
 <summary>
 Returns the floored X offset in terms of grid cells.
 </summary>
</member>
<member name="P:Migration.CyclePoint.YGrid">
 <summary>
 Returns the floored Y offset in terms of grid cells.
 </summary>
</member>
<member name="P:Migration.CyclePoint.Y">
 <summary>
 Returns the double precision Y offset in terms of grid cells.
 </summary>
</member>
<member name="P:Migration.CyclePoint.X">
 <summary>
 Returns the double precision X offset in terms of grid cells.
 </summary>
</member>
<member name="M:Migration.CyclePoint.FromGrid(Migration.Point)">
 <summary>
 Converts a grid position into a cycle point.
 </summary>
</member>
<member name="M:Migration.CyclePoint.FromGrid(System.Double,System.Double)">
 <summary>
 Converts a grid position into a cycle point.
 </summary>
</member>
<member name="M:Migration.CyclePoint.ToPoint">
 <summary>
 Converts a cycle point into an integer grid position.
 </summary>
</member>
<member name="M:Migration.CyclePoint.#ctor(System.Int64,System.Int64)">
 <summary>
 Initializes a cycle point structure with raw cycle offsets. You should
 only use this when you know what you are doing ;).
 </summary>
</member>
<member name="M:Migration.CyclePoint.AddCycleVector(Migration.Point)">
 <summary>
 The only deterministic way to change a cycle point, by raw cycle manipulation.
 </summary>
</member>
<member name="T:Migration.RoutingNode">
 <summary>
 Routing nodes represent a network graph which provides a higher granulated level
 
 </summary>
</member>
<member name="F:Migration.RoutingNode.Neighbors">
 <summary>
 There are eight neighbors starting from 12:00 clockwise in 45 degree steps.
 If there is no such neighbor for a given direction, the entry is NULL.
 </summary>
</member>
<member name="T:Migration.Jobs.JobOrder">
 <summary>
 The job is able to override the movable's direction. This is necessary for construction workers
 and fighting soldiers for example.
 </summary>
</member>
<member name="T:Migration.Jobs.JobBase">
 <summary>
 Jobs are used by movables to do tasks like wood cutting, carrying, building, fighting,
 stealing, etc. They provide a generic way to accomplish these tasks in a synchronized,
 stable and straighforward manner. Each movable can only have one job at maximum. If it
 does, it is considered non-free and thus not eligable to get another job. The job itself
 is permanent and thus gets repeated if return "true".
 </summary>
</member>
<member name="M:Migration.Jobs.JobBase.Prepare">
 <summary>
 should be overwritten in a subclass. The task here is to determine whether the job
 can be executed by now and if so, returns "true", "false" otherwise. Further, one
 should add some initial animation steps, otherwise the job will finish immediately.
 </summary>
 <returns></returns>
</member>
<member name="M:Migration.Jobs.JobBase.Stop">
 <summary>
 Asynchronously aborts the job on next update. 
 </summary>
</member>
<member name="M:Migration.Jobs.JobBase.AddAnimationStep(Migration.Point,System.Func{System.Boolean},System.Func{System.Boolean,System.Boolean})">
 <summary>
 Lets the movable walk to the given destination and call <paramref name="onStepCompleted"/>
 with "true" if the target has been reached and "false" otherwise. The callback should
 return "true" if the job should continue and "false" if the job should be aborted. You
 may add new animation steps within the callback! Animation steps are removed from the
 internal list, once they were executed (regardless of success/failure).
 </summary>
</member>
<member name="M:Migration.Jobs.JobBase.AddAnimationStep(Migration.Common.Procedure{Migration.Common.Procedure})">
 <summary>
 Allows the caller to inject a fully customized animation step into the timeline.
 The step is completed, when the given lambda expression in return raises the 
 passed animation completion handler.
 </summary>
</member>
<member name="M:Migration.Jobs.JobBase.AddAnimationStepWithPathFollow(System.Int32,System.Func{System.Boolean},System.Func{System.Boolean,System.Boolean})">
 <summary>
 Calls <paramref name="onStepStarted"/> when animation has reached this step and if
 "true" is returned by the callback it will just wait the given time in millis rounded
 up to the next cycle time boundary. Afterwards <param name="onStepCompleted"/> is called.
 The callback should return "true" if the job should continue and "false" if the job 
 should be aborted. You may add new animation steps within the callback! Animation steps 
 are removed from the internal list, once they were executed (regardless of success/failure).
 </summary>
</member>
<member name="M:Migration.Jobs.JobBase.Update">
 <summary>
 Is used internally to update the job status.
 </summary>
</member>
<member name="T:Migration.ResourceManager">
 <summary>
 The resource manager, as its name implies, takes track of all resource stacks in the game.
 It also seeks for Migrants carrying resources from provider to queries in a prioritized
 way. This is very important, since it ensures that queries with lower VirtualCount
 will come first, which has a significant positive impact on the whole economy. In the original
 game this was not enforced, this combined with the fact that there seemed to be a limit of
 resources being carried, it was just a burden if not impossible to get a huge settlement
 running properly.
 </summary>
</member>
<member name="F:Migration.ResourceManager.m_Resources">
 <summary>
 All resources and queries are put into this list.
 </summary>
</member>
<member name="F:Migration.ResourceManager.m_Queries">
 <summary>
 All queries will also go here, as long as their VirtualCount is
 less than their MaxStack size. If this is the case you will find
 the query in the list with index VirtualCount.
 </summary>
</member>
<member name="F:Migration.ResourceManager.privateManager">
 <summary>
 The associated movable manager.
 </summary>
</member>
<member name="E:Migration.ResourceManager.OnAddStack">
 <summary>
 Is raised whenever a resource stack is added.
 </summary>
</member>
<member name="E:Migration.ResourceManager.OnRemoveStack">
 <summary>
 Is raised whenever a resource stack is removed.
 </summary>
</member>
<member name="M:Migration.ResourceManager.AddResourceStack(Migration.CyclePoint,Migration.Common.StackType,Migration.Common.Resource,System.Int32)">
 <summary>
 Adds a new resource stack with the given parameters and raises <see cref="E:Migration.ResourceManager.OnAddStack"/>.
 This method is also called internally and it is crucial to do all postprocessings meant to
 be applied for all resource stacks, like attaching a visual for rendering, in the mentioned event.
 </summary>
 <exception cref="T:System.ArgumentException">There is already a resource or the given position is not walkable.</exception>
</member>
<member name="M:Migration.ResourceManager.OnStackCountChanged(Migration.GenericResourceStack,System.Int32,System.Int32)">
 <summary>
 For resource queries we need to keep track of their stack size, since we have
 to relocate them appropriately in the priority queue.
 </summary>
</member>
<member name="M:Migration.ResourceManager.DropResource(Migration.Point,Migration.Common.Resource,System.Int32)">
 <summary>
 If no resource exists at the given grid point, a new resource provider is added and
 filled. Otherwise the existing stack is used if it is of the same resource type.
 If <paramref name="inCount"/> exceeds the remaining stack capacity, the method enumerates
 around the given point and repeats the task until all desired resources are placed.
 </summary>
 <remarks>
 This is an important method also demonstrating how powerful our lightweight resource
 concept is. With almost no effort we can simulate resource drops in the same way they
 are done in the original game.
 </remarks>
 <param name="inAround">You may also pass unwalkable spots. The method enumerates until it finds one.</param>
 <param name="inResource">The resource type being dropped.</param>
 <param name="inCount">Amount of resources being dropped.</param>
</member>
<member name="M:Migration.ResourceManager.RemoveResource(Migration.GenericResourceStack)">
 <summary>
 Removes the given stack. Please keep in mind that this method is also called
 internally and it is crucial that you put ALL additional code required to release
 the resource stack into the event handler <see cref="E:Migration.ResourceManager.OnRemoveStack"/>, like
 detaching it from the render pipeline.
 </summary>
 <exception cref="T:System.ArgumentNullException">No resource given.</exception>
 <exception cref="T:System.ApplicationException">Resource does not exist.</exception>
</member>
<member name="M:Migration.ResourceManager.ProcessCycle">
 <summary>
 Will do all the job planning.
 </summary>
</member>
<member name="T:Migration.Movable">
 <summary>
 The base class for all movables. 
 </summary>
</member>
<member name="F:Migration.Movable.privateCurrentNode">
 <summary>
 The current path node. TODO: In future this should be a read-only property
 which efficiently determines its value instead of being set explicitly.
 </summary>
</member>
<member name="F:Migration.Movable.privatePath">
 <summary>
 A list of path nodes currently in the queue.
 </summary>
</member>
<member name="F:Migration.Movable.privateMovableType">
 <summary>
 The movable type. Currently ignored, but later this will provide ways to,
 for example, letting soldiers walk over snow while Migrants couldn't.
 </summary>
</member>
<member name="P:Migration.Movable.ReplanTime">
 <summary>
 The time when the engine should issue a new path. This is usually the time
 of the last path node.
 </summary>
</member>
<member name="F:Migration.Movable.privateCycleSpeed">
 <summary>
 This instance will take <see cref="P:Migration.Movable.CycleSpeed"/> times the <see cref="P:Migration.SynchronizedManager.CycleResolution"/>
 to pass one grid cell. Currently this value is readonly and hardcoded to one (due to lack of support
 of the path engine, since it would make much things unnecessary complicated which should be avoided
 as long as the path engine itself is not feature complete; and to be honest it is already complicated enough
 to understand cooperative path planning even without having to think of different speeds and sizes; to
 be precise in theory it is easy but we are using a highly optimized version that additionally has a discrete 
 space-time and is 100% deterministic).
 </summary>
</member>
<member name="F:Migration.Movable.privatePathTarget">
 <summary>
 This is the grid cell where this instance is being moved to.
 </summary>
</member>
<member name="F:Migration.Movable.privateParent">
 <summary>
 The movable manager this instance is attached to (or null).
 </summary>
</member>
<member name="F:Migration.Movable.privateResultHandler">
 <summary>
 An optional handler being called when the movable has reached its target
 or is stopped.
 </summary>
</member>
<member name="P:Migration.Movable.HasJob">
 <summary>
 Is this instance currently carrying out a job?
 </summary>
</member>
<member name="P:Migration.Movable.Carrying">
 <summary>
 If any, the resource currently carried (an eventually dropped) by this instance.
 </summary>
</member>
<member name="M:Migration.Movable.SetPosition_YouMustNotDoThis(Migration.CyclePoint)">
 <summary>
 Well yes, you must not do this. This method is only exported for the path planning engine and calling it
 outside the right context may immediately crash the game! There is simply NO way to change a movable's
 position without the path planning engine or by passing a proper position in the constructor. Well to be
 true, there are rare exceptions but you have to be extremely careful and to know what you are doing...
 </summary>
 <param name="inNewPosition"></param>
</member>
<member name="P:Migration.Movable.IsIdle">
 <summary>
 Is movable eligable for new jobs?
 </summary>
</member>
<member name="E:Migration.Movable.OnPositionChanged">
 <summary>
 Is raised by <see cref="M:Migration.MovableManager.ProcessCycle"/> whenever it changes the movable position.
 </summary>
</member>
<member name="E:Migration.Movable.OnStop">
 <summary>
 Is raised whenever Stop is called.
 </summary>
</member>
<member name="M:Migration.Movable.RaisePositionChange(Migration.CyclePoint)">
 <summary>
 Is raised by <see cref="M:Migration.MovableManager.ProcessCycle"/> whenever it changes the movable position.
 </summary>
</member>
<member name="P:Migration.Movable.IsMoving">
 <summary>
 An object only is considered moving if its current path node got a direction, the only case in 
 which true is returned.
 </summary>
</member>
<member name="M:Migration.Movable.Stop">
 <summary>
 Stops movable in next aligned cycle, causing it to drop resources being carried (if any),
 and becoming idle.
 </summary>
</member>
<member name="T:Migration.MovableManager">
 <summary>
 The movable manager is the internal interface to pathfinding. Every movable is added here and 
 the only (intended) way to change its position is by using SetPath. The most
 important thing everyone should keep in mind about this path engine: It is deterministic in
 the strongest way, meaning it is 100% deterministic within a discrete space-time. This is a very
 important foundation for later network synchronization and saving games.
 </summary>
</member>
<member name="F:Migration.MovableManager.privateSize">
 <summary>
 Width and/or Height in TerrainCells. For performance reasons width and height will always
 have the same value and must be a power of two. But don't rely on that outside the path engine.
 </summary>
</member>
<member name="E:Migration.MovableManager.OnAddMovable">
 <summary>
 Will be called once for every added movable.
 </summary>
</member>
<member name="E:Migration.MovableManager.OnRemoveMovable">
 <summary>
 Will be called once for every removed movable.
 </summary>
</member>
<member name="M:Migration.MovableManager.IsWalkable(Migration.Point,Migration.Common.MovableType)">
 <summary>
 Can a movable of the given type walk on given cell?
 </summary>
 <param name="inCell">Starting at (0,0) the grid position on <see cref="P:Migration.MovableManager.Terrain"/> in TerrainCells.</param>
 <param name="inMovableType">An integer movable type.</param>
 <returns></returns>
</member>
<member name="M:Migration.MovableManager.#ctor(Migration.Game.Map,System.Int64,System.Int64)">
 <summary>
 Creates a new instance.
 </summary>
 <param name="inMap">Desired terrain grid width (height) in TerrainCells. Must be a power of two.</param>
 <param name="inCurrentCycle">An initial value for <see cref="P:Migration.SynchronizedManager.CurrentCycle"/>.</param>
 <param name="inCycleResolution">Desired value for <see cref="P:Migration.SynchronizedManager.CycleResolution"/>.</param>
</member>
<member name="M:Migration.MovableManager.AcquirePath(Migration.Movable)">
 <summary>
 The only place where new paths are acquired. 
 </summary>
</member>
<member name="M:Migration.MovableManager.InterpolateMovablePosition(Migration.Movable,Migration.Common.Direction@,Migration.CyclePoint@,System.Double@)">
 <summary>
 Even though position interpolation does not really belong here, and instead should be
 kept in a renderer or whatever, it requires a bunch of internal knowledge about path
 planning if you want to implement it efficiently. And thus it is much cleaner to
 put this method here instead of exposing the path planning internals to the public!
 </summary>
 <param name="inMovable"></param>
 <param name="refDirection"></param>
 <param name="outXYInterpolation"></param>
 <param name="outZInterpolation"></param>
</member>
<member name="M:Migration.MovableManager.EnumMovablesAround(Migration.Point,System.Func{Migration.Movable,Migration.Common.WalkResult})">
 <summary>
 Enumerates movables around the given grid position with increasing distance on average (meaning
 is is not strongly sorted by distance, for performance reasons).
 </summary>
 <param name="inAround"></param>
 <param name="inHandler"></param>
 <returns></returns>
</member>
<member name="M:Migration.MovableManager.AddMovable(Migration.CyclePoint,Migration.Common.MovableType)">
 <summary>
 It is not checked whether the movable
 can be placed/walk where it is. If it can't walk or is to be placed on a non-movable object, it will 
 immediately die. Allocated movables have to be released with ReleaseMovable.
 On success, <see cref="E:Migration.MovableManager.OnAddMovable"/> will be raised.
 </summary>
</member>
<member name="M:Migration.MovableManager.MarkMovableForRemoval(Migration.Movable)">
 <summary>
 Marks the given movable for removal. The manager may decide the specific point of removal on
 his convenience. In contrast, the <see cref="E:Migration.MovableManager.OnRemoveMovable"/> event is called BEFORE this method
 returns!
 </summary>
</member>
<member name="M:Migration.MovableManager.SetPath(Migration.Movable,Migration.Point)">
 <summary>
 See <see cref="M:Migration.MovableManager.SetPath(Migration.Movable)"/>.
 </summary>
</member>
<member name="M:Migration.MovableManager.SetPath(Migration.Movable,Migration.Point,Migration.Common.Procedure{System.Boolean})">
 <summary>
 Sets a path with an optional result handler. It is not guaranteed that a path can be
 found, neither that it will be reached. What is guaranteed is that the result handler
 is called in any case and only with "true" as parameter if the movable has reached its
 destination. Further, a movable with a pending result handler is considered to be non-idle.
 If you try to set a path for a movable with a pending result handler ("doing a job"), the 
 call will immediately throw an exception!
 </summary>
 <param name="inMovable">Movable to plan a path for.</param>
 <param name="inTarget">Destination for the movable.</param>
 <param name="inResultHandler">An optional result handler.</param>
 <exception cref="T:System.InvalidOperationException">The movable is already doing a job. Call Stop() first.</exception>
</member>
<member name="M:Migration.MovableManager.SetPath(System.Collections.Generic.IEnumerable{Migration.Movable},Migration.Point)">
 <summary>
 See <see cref="M:Migration.MovableManager.SetPath(Migration.Movable)"/>.
 </summary>
</member>
<member name="M:Migration.MovableManager.SetPath(System.Collections.Generic.IEnumerable{Migration.Movable},Migration.Point,Migration.Common.Procedure{System.Boolean})">
 <summary>
 See <see cref="M:Migration.MovableManager.SetPath(Migration.Movable)"/>.
 </summary>
</member>
<member name="T:Migration.MovablePathNode">
 <summary>
 Intended to provide some default behavior for all essentially non-movable objects,
 which still are renderable, like resources or buildings.
 </summary>
</member>
<member name="F:Migration.MovablePathNode.privatePosition">
 <summary>
 The corresponding key for the internal space-time map.
 </summary>
</member>
<member name="F:Migration.MovablePathNode.privateDirection">
 <summary>
 A direction of animation, if any.
 </summary>
</member>
<member name="P:Migration.MovablePathNode.IsIdle">
 <summary>
 A path node is idle, if it has no direction.
 </summary>
</member>
<member name="F:Migration.MovablePathNode.privateMovable">
 <summary>
 The movable owning this path node.
 </summary>
</member>
<member name="T:Migration.PositionTracker">
 <summary>
 Intended to provide some default behavior for all essentially non-movable objects,
 which still are renderable, like resources or buildings.
 </summary>
</member>
<member name="T:Migration.TerrainRouting">
 <summary>
 In constrast to user controlables, which are currently not supported, AI controlables need 
 to be planned under strong constraints, since the user has almost no chance to correct
 misplanned paths or even cycle loops. The following class will make strong path planning
 more efficient by providing precomputed routes through the map. So instead of having to
 calculate the entire path, a movable only needs to compute the path to the next global 
 path node and then follow the precomputed route to the target global path node. Now again
 another short path is being computed to the precise target. Later, this it will be possible
 to implement some sort of easy and fast cooperative path planning along these routes while
 using the same technique as used for user controlables (which is not implemented yet) to
 schedule the cooperative paths from and to the global path route. Both techniques together
 will allow to handle even 60.000 units in a cooperative and solid way maybe even on embedded
 devices. Later, the routing should also be updated when terrain changes through priest spells
 for example. For now only buildings and foilage are taken into account as dynamic parameter.
 </summary>
</member>
<member name="M:Migration.TerrainRouting.AreConnected(Migration.Point,Migration.Point)">
 <summary>
 Checks wether a path could be found between two nodes, if attempted. This method
 executes in constant time and should always be checked before a path search is
 invoked. Failed path searches are computational extremely expensive.
 </summary>
</member>
<member name="M:Migration.PriorityQueue`1.Push(`0)">
 <summary>
 Push an object onto the PQ
 </summary>
 <returns>The index in the list where the object is _now_. This will change when objects are taken from or put onto the PQ.</returns>
</member>
<member name="M:Migration.PriorityQueue`1.Pop">
 <summary>
 Get the smallest object and remove it.
 </summary>
 <returns>The smallest object</returns>
</member>
<member name="M:Migration.PriorityQueue`1.Update(`0)">
 <summary>
 Notify the PQ that the object at position i has changed
 and the PQ needs to restore order.
 </summary>
</member>
<member name="M:Migration.PriorityQueue`1.Peek">
 <summary>
 Get the smallest object without removing it.
 </summary>
 <returns>The smallest object</returns>
</member>
<member name="M:Migration.TerrainDefinition.InitializeWallAt(Migration.Point,Migration.Common.WallValue,Migration.Rectangle[])">
 <summary>
 Only sets the wall if the target cells are free.
 </summary>
</member>
<member name="M:Migration.TerrainDefinition.DrawToHeightmap(System.Int32,System.Int32,Migration.TerrainBrush)">
 <summary>
 Changes the height of the given cell as well as its surrounding accordingly to
 the given brush. These painting operations are the preferred way of changing
 terrain properties, since they cause a more natural look and feel.
 </summary>
 <param name="inXCell"></param>
 <param name="inYCell"></param>
 <param name="inBrush"></param>
</member>
<member name="M:Migration.TerrainDefinition.AverageDrawToHeightmap(System.Int32,System.Int32,System.Int32,Migration.TerrainBrush)">
 <summary>
 Instead of <see cref="M:Migration.TerrainDefinition.DrawToHeightmap(System.Int32,System.Int32,Migration.TerrainBrush)"/>, this one will use the brush to reduce
 the terrain variance from average. This will in fact grade the terrain to the
 given average height by using the brush as weight for each surrounding cell.
 </summary>
 <param name="inXCell"></param>
 <param name="inYCell"></param>
 <param name="inAvgHeight"></param>
 <param name="inBrush"></param>
</member>
<member name="M:Migration.XMLTerrainGenerator.Save(System.Double[])">
 <summary>
 This procedure just simply manipulates image colors and then saves the image file
 </summary>
 <param name="inData"></param>
 <remarks></remarks>
</member>
<member name="T:Migration.GenericResourceStack">
 <summary>
 A resource stack is a integral part of the whole economy. Its a simple but powerful
 concept with which most resource tasks seen in Migrants can be archieved.
 </summary>
</member>
<member name="F:Migration.GenericResourceStack.DEFAULT_STACK_SIZE">
 <summary>
 There is a maximum number of items supported for ALL resource stacks.
 </summary>
</member>
<member name="F:Migration.GenericResourceStack.privateBuilding">
 <summary>
 The building, if any, this stack is attached to.
 </summary>
</member>
<member name="F:Migration.GenericResourceStack.privateType">
 <summary>
 Kind of this stack.
 </summary>
</member>
<member name="F:Migration.GenericResourceStack.privateResource">
 <summary>
 Resource typed stored here.
 </summary>
</member>
<member name="E:Migration.GenericResourceStack.OnCountChanged">
 <summary>
 Is raised whenever resources are removed or added.
 </summary>
</member>
<member name="E:Migration.GenericResourceStack.OnMaxCountChanged">
 <summary>
 Is raised whenever <see cref="P:Migration.GenericResourceStack.MaxCount"/> changes.
 </summary>
</member>
<member name="P:Migration.GenericResourceStack.MaxCount">
 <summary>
 For each instance you can set the maximum stack size between
 one and <see cref="F:Migration.GenericResourceStack.DEFAULT_STACK_SIZE"/>.
 </summary>
</member>
<member name="P:Migration.GenericResourceStack.VirtualCount">
 <summary>
 The virutal resource count is calculated differently for queries and
 providers. For queries it is the sum of <see cref="P:Migration.GenericResourceStack.Available"/> and
 <see cref="P:Migration.GenericResourceStack.Requested"/>, for providers its the difference. 
 </summary>
 <remarks>
 Further a query is considered to be full if this value has reached the maximum
 stack size, even if for now not all resources are actually added to the
 stack, but on their way. A provider can also be empty even if there is
 the maximum possible amount of resources stored.
 </remarks>
</member>
<member name="P:Migration.GenericResourceStack.Available">
 <summary>
 The amount of resources building this stack. This does NOT include resource
 jobs that will decrease or increase the stack count in near future.
 </summary>
</member>
<member name="P:Migration.GenericResourceStack.Requested">
 <summary>
 The amount of resource job regarding this stack. This does NOT include resources
 already placed on the stack.
 </summary>
</member>
<member name="M:Migration.GenericResourceStack.AddResource">
 <summary>
 Adds a resource, depending on stack type, directly, meaning it will increase
 <see cref="P:Migration.GenericResourceStack.Available"/>.
 </summary>
 <exception cref="T:System.ArgumentOutOfRangeException">Adding a resource would overflow the stack.</exception>
</member>
<member name="M:Migration.GenericResourceStack.AddJob(Migration.Movable)">
 <summary>
 Adds a resource job, depending on stack type, meaning it will increase
 <see cref="P:Migration.GenericResourceStack.Requested"/>.
 </summary>
 <exception cref="T:System.ArgumentOutOfRangeException">Adding another resource would overflow the stack.</exception>
</member>
<member name="M:Migration.GenericResourceStack.RemoveResource">
 <summary>
 Adds a resource, depending on stack type, directly, meaning it will increase
 <see cref="P:Migration.GenericResourceStack.Available"/>.
 </summary>
 <exception cref="T:System.Collections.Generic.KeyNotFoundException">No resource available to remove.</exception>
</member>
<member name="M:Migration.GenericResourceStack.RemoveJob(Migration.Movable)">
 <summary>
 Removes a resource job meaning it will decrease <see cref="P:Migration.GenericResourceStack.Requested"/>.
 </summary>
 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Given movable was not found.</exception>
</member>
<member name="T:Migration.Map`2">
 <summary>
 A more flexible solution than the original SortedList provided by Microsoft.
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
</member>
<member name="M:Migration.Map`2.InitializeSortedUnsafe(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
 <summary>
 Only use this method for high-performance cases, since initial sorting is not enforced. This may lead
 to a corrupted map if you don't know exactly that the given pairs are already sorted!
 </summary>
 <param name="inPairs"></param>
</member>
<member name="M:Migration.GridSearch.#ctor">
 <summary>
 Invokes the handler with values, walking along the whole grid in a rectangular
 spiral around start position. What exactly is the "grid" is within your power.
 </summary>
</member>
<member name="M:Migration.GridSearch.GridCircleAround(Migration.Point,System.Int32,System.Int32,System.Int32,System.Int32,Migration.Common.Procedure{Migration.Point})">
 <summary>
 Circles around the given center while maintaining a constant distance of <paramref name="inRadius"/>
 to the center and a distance of <paramref name="inStepWidth"/> to the previous call of the handler,
 if possible. In contrast to WalkAround, this method does NOT cover an area but only a
 closed line (approx. a circle). 
 </summary>
 <param name="inCenter"></param>
 <param name="inRadius"></param>
 <param name="inStepWidth"></param>
 <param name="inHandler"></param>
</member>
<member name="T:Migration.TopologicalList`1">
 <summary>
 A topological list is meant to provide a highly optimized way of doing jobs like
 "give me all resources around XY sorted ascendingly by distance to XY". Since this
 is a very important and frequently used operation in the game, its worth to create
 a special list for it. Please be aware of that this list only ensurs sorting by
 distance in an approximative way, based on the granularity given. If you use 1 as
 granularity, which would definitely be stupid, you would get exact sorting by distance.
 If you choose 10, the same task will have an error of 10 length units on average, which
 doesn't matter at all for this game, but exponentially speeds up performance.
 </summary>
 <typeparam name="TValue"></typeparam>
</member>
<member name="M:Migration.TopologicalList`1.EnumAround(Migration.Point,System.Int32,System.Func{`0,Migration.Common.WalkResult})">
 <summary>
 If you want to limit the radius of <see cref="M:Migration.TopologicalList`1.EnumAround(Migration.Point,System.Func{`0,Migration.Common.WalkResult})"/>, it is recommended using this function,
 since it is not obvious how to archieve this from outside the topological list!
 </summary>
</member>
<member name="T:Migration.Point">
 <summary>
 To prepent System.Drawing dependency just for this structure.
 </summary>
</member>
<member name="P:Migration.SynchronizedManager.NextAlignedCycle">
 <summary>
 The next cycle time aligned to <see cref="P:Migration.SynchronizedManager.CycleResolution"/>. If <see cref="P:Migration.SynchronizedManager.CurrentCycle"/>
 is already aligned, the next aligned cycle is still returned.
 </summary>
</member>
<member name="P:Migration.SynchronizedManager.CurrentCycle">
 <summary>
 The current discrete time value. By convention, everwhere else you need a discrete game time,
 just return this value of the path engine.
 </summary>
</member>
<member name="P:Migration.SynchronizedManager.CycleResolution">
 <summary>
 Directly holds the discretization granularity. All movable speeds can only be multiples of
 this value, but be careful, since performance goes down polynomial (?just a guess) with 
 increasing resolution.
 </summary>
</member>
<member name="T:Migration.UniqueIDObject">
 <summary>
 Since the economy is fully deterministic, it is a very handy idea to ultimately derive some important
 objects like jobs, movables and the like from DebugObject, providing unique IDs and debug methods
 for easy bug tracking.
 </summary>
</member>
<member name="M:Migration.VisualUtilities.SynchronizeTask(Migration.Common.Procedure)">
 <summary>
 Schedules the given task for execution at the next rendering cycle. 
 </summary>
</member>
<member name="T:System.CrossRandom">
 <summary>
 Mersenne Twister Random Generator
 </summary>
</member>
</members>
</doc>
